<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Integration Testing</title>
  <link rel="icon" href="data:;base64,=">
  <style>body {margin: 0;} canvas {display: block;}</style>
</head>
<body>
  
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/107/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
<script src="../dist/gl-bench.js"></script>
<script>
    let scene;
    let camera;
    let renderer;
    
    let stats = new Stats();
    stats.showPanel(0);
    document.body.appendChild( stats.dom );
    let bench = new GlBench();
    
    let len = { count: 1000000 };
    var gui = new dat.GUI();
    gui.add(len, 'count', 10000, 5000000).onFinishChange(dumbUpdate);
    
    function setup() {
      setupScene();
      setupCamera();
      setupRenderer();
      setupParticles();
      setupEventListeners();
    }
    
    function dumbUpdate() {
      scene.remove(scene.children[0]);
      setupParticles();
    }
    
    function setupScene() {
      scene = new THREE.Scene();
    }
    
    function setupCamera() {
      let res = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(70, res, 1, 10000);
    }
    
    function setupRenderer() {
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }
    
    function setupParticles() {
      let geometry = new THREE.Geometry();
      addLorenzVertices(geometry);
      let color = new THREE.Color(0xbb00ff);
      for (let i = 0; i < len.count; i++) {
        geometry.colors.push(color);
      }
      let material = new THREE.PointsMaterial({ size: 1, vertexColors: THREE.VertexColors, depthTest: false, opacity: 0.3, sizeAttenuation: false, transparent: true });
      let mesh = new THREE.Points(geometry, material);
      scene.add(mesh);
    }
    
    function setupEventListeners() {
      window.addEventListener("resize", onWindowResize);
    }
    
    function addLorenzVertices(geometry) {
      let x0 = 0.1;
      let y0 = 0;
      let z0 = 0; 
      let x1, y1, z1;
      let h = 0.001;
      let a = 10.0;
      let b = 28.0;
      let c = 8.0 / 3.0;
    
      for (let i = 0; i < len.count; i++) {
        x1 = x0 + h * a * (y0 - x0);
        y1 = y0 + h * (x0 * (b - z0) - y0);
        z1 = z0 + h * (x0 * y0 - c * z0);
        x0 = x1;
        y0 = y1;
        z0 = z1;
        let vertex = new THREE.Vector3(
          x0, 
          y0, 
          z0-24);
        geometry.vertices.push(vertex);
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function movePosition(position, phase) {
      let r = 40;
      let θ = new Date() * 0.0005 + 10;
      let φ = new Date() * 0.0005;    
      let x = r * Math.sin(φ + phase) * Math.cos(θ + phase);
      let y = r * Math.sin(φ + phase) * Math.sin(θ + phase);
      let z = r * Math.cos(φ + phase);
      position.set(x, y, z);
    }
    
    function draw() {
      stats.update();
      bench.update();
      movePosition(camera.position, 0);
      camera.lookAt(scene.position);
      renderer.render(scene, camera);
      requestAnimationFrame(draw);
    }
    
    setup();
    draw();
    </script>
</html>